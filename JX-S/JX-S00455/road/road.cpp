#include <bits/stdc++.h>
using namespace std; const int N = 10010, M = 100010, K = 12; int n, m, h[N], fl[N], dt[N], cnt, fa[N], ans, a[K][N] ,c[K], k; struct node{int v, w, nt; }e[M]; struct de{ int u, v, w; }eg[M];
int djstl(int st ){ for(int i = 1;i <= n;i++){ fl[i] = 0; dt[i] = INT_MAX; } dt[st] = 0; priority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int >>> pq; pq.push({0,st}); while(!pq.empty()){ int u = pq.top().second; int w = pq.top().first; pq.pop(); for(int i = h[u]; i != -1; i = e[h[u]].nt){ int v = e[i].v; if(dt[u] + w < dt[v]){ dt[v]=dt[u] + w; pq.push({ v, dt[v]}); } } } }
void add(int u, int v, int w ){  e[cnt].v = v; e[cnt].w = w; e[cnt].nt = h[u]; h[u] = cnt ++; }
void md(int a, int b ){ if( fa[a] != fa[b] ) fa[a] = fa[b]; } int find(int x ){ if(fa[x] == x){ return x; } return find(fa[x]); } bool cmp(de a, de b ){ return a.w < b.w; }
void zxscs(){ int sum = 0; sort(eg + 1,eg + m + 1,cmp); for(int i = 1;i<=m;i++){ if(fa[eg[i].u] == fa[eg[i].v]){ continue; } ans += eg[i].w; fa[eg[i].u] = fa[eg[i].v]; add(eg[i].u,eg[i].v,eg[i].w); sum++; if(sum == n-1) { break; } } }
int main(){ freopen("road.in", "r", stdin ); freopen("road.out", "w", stdout ); cin >> n >> m >> k; for(int i = 1;i <= n;i ++){ h[i]=-1; fa[i] = i; } for(int i = 1;i <= m;i ++){ cin >> eg[i].u >> eg[i].v >> eg[i].w; } zxscs(); djstl(1); for(int i = 1;i <= k;i ++){ cin >> c[i]; for(int j = 1;j <= n;j ++){ cin >> a[i][j]; } } for(int i = 1; i <= k; i ++){ for(int aa = 1;aa <= n;aa ++){ for(int cost, bb = aa + 1; bb <= n; bb ++){ if(fa[aa] == fa[bb] && fa[aa] == 1){ cost = dt[aa] + dt[bb]; } else { cost = max(dt[aa], dt[bb])-min(dt[aa], dt[bb] ); } if(a[i][aa] + a[i][bb] + c[i] < cost){ ans=ans - cost + a[i][aa] + a[i][bb] + c[i]; int mn, mx; if(dt[aa]>dt[bb]) {mn = aa, mx = bb;} else {mn = bb, mx = aa;} dt[mn] = dt[mx] + a[i][aa] + a[i][bb]; } }}} cout << ans; return 0; }
