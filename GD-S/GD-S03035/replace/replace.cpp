#include<bits/stdc++.h>
#define int long long

using namespace std;
const int mod = 998244353;
const int N = 1e6 + 10;

int n, m, a[N], ans = 1, cnt;
string s1, s2;

signed main(){
	freopen("replace.in", "r", stdin);
	freopen("replace.out", "w", stdout);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> s1 >> s2;
	for(int i = 1; i <= m; i++){
		cin >> s1 >> s2;
		cout << 0 << endl;
	}
}
/*
来一篇游记吧剩一个钟不知道干啥
2：30发解压码但是我们的解压码漏了一个字（过了有会才说）浪费掉3分钟
大约2：38看到题目（因为我解压文件之后把上级文件关闭导致下级没法解开，开始还不知道这点
看到题目第一题就跳过了，刚开始感觉没思路
第二题一开始想的分层图但是看了一下好像不太需要 ，直接最小生成树跑一遍差不多（再多我也想不到了
但是有意思的是我的Dev这时候一直打不开我以为电脑的问题就保存了一下文件到D盘然后重启
重启过了10分钟监考老师说这个电脑是这样的，Dev有时候打不开叫我们一直开着
难蚌
之后就是我把编译环境改完发现运行有问题，监考老师说是我自己代码写的，他不知道，于是我又重启了一次
因为这建事甚至我重新下了一个Dev在电脑上
完事发现还是不行于是直接果断继续重启
浪费一个钟（ps：到现在考试过去两个钟了）
然后重新看向第一题，这时候出思路了
我的思路大体上是先让所有人选最大的，如果发现哪个选择的人数超出n/2的话
把多出来的看一下（举个例子，4 3 2开始先选第一个社团，然后记录一下（4-3 < 3-2））
其实就是记录所有超出的换到第二选择所花费的代价，例子中记录4-3=1（因为代价小）
正确性其实很显然
4 2 1
4 3 2
5 3 4
4 1 4
自己造的样例，开始所有都选1，结果为4 + 4 + 5 + 4 = 17；
改变所消耗的代价为2 1 1 0
比较大小（小在前得0 1 1 2
答案为17 - 0 - 1 = 16
到这还有一个小时20分钟结束（感觉出思路打题还是很快的，而且把所有样例监测了一遍都过了ps：虽然没什么价值，指的是大样例（水货来着））
然后就是骗分，第三题没思路感觉像模拟
全部写0过了
第四题同样没思路拿性质A的分
写着写着发现不对啊好像有坑
因为ci没说不能为0，为0相当于直接放弃了那就把为0的记录一下
如果n == cnt + m就输出2的n次方取余mod
ok到这里剩一个钟正好
写篇游记还有45分钟（或许骗完分还有80分钟？我感觉写游记没那么快a） 
*/ 
