/*
T4 的话
我第一眼看上去开心了一下，我以为是求能围成的最大多边形（这个玩意是最近一场CF的恶心题，身为D2C在luogu评紫，刚好我还记得怎么做）
结果呢？你告诉我这个计数、
我恨数数，做出恨意，做到呕吐
我谢谢你，给我个图论建模然我AK好不好啊啊啊啊啊
不过也不是不能做，我们分析一下，首先由于CCF是断网的比赛
它贴心的给我们怎么判断多边形是否合法的标准。
出题人讲的有点烂，说人话就是除了最大边剩下的加起来要大于最大的（我讲的是不是更烂，但是出题人特意写了个2*max是何意味）
 不过啊，我们稍微分析一下，这题的计数味道其实不浓（现在我能AK了！！！）
 我们先把数列排一个序，钦定第i位最大时答案就是你往前二分一个最小的j，使得sj（前缀和数组）>ai
 容易发现此时j~i这个区间在有选择前缀的情况下可以乱选
 不过显然。前缀不一定要选，在这里我们卡住了，返回去看一眼数据范围。
 n le 5000，显然的告诉我们要n^2
 max ai le 5000，何意味呢
 我们必须要从小n入手， 暴力枚举是i边形这个时候我的直觉告诉我这是一个dp计数
 我们设dpi j为i边形，选了j条边的数量。
 这个状态所包含的信息一眼少了
 如果我们使用状压，设dpi mask为选条边，边的集合为mask的方案数，转移分类讨论新加的边是最大的还是原有的即可。
 时间复杂度n*2^n期望得分60分
 但是咱这辈子是不可能在不是状压的题目上写状压的，毕竟这一档分数因该是给搜索的
 虽然咱不写状压 ，但是状压的转移是很有意义的，好好反思一下，我们就会发现
 我们的dp状态一开始就有点问题
 不妨设dpi j为前i位，选了j个数（对，就是背包）的方案数
发现仍然无法转移（不过我相信距离正解还有几步之遥）
观察数据范围。有个max ai的设定啊，着你还看不懂吗
max ai告诉我们什么，sum ai啊
sum ai*n le n^2 啊
不妨设dp i t为前i个数，选的数和为ai的方案数，转移的时候分2类讨论， 选的数若是大于ai。则不能选，小于ai，就可以选
方程是容易得到的就是dp i t=\sum_{j=1}^{j<=i}dp j t-ai [t-ai>ai] 
缺点有几个，第一个是复杂度，复杂度n^3，还有就是。必须要找到一个合法的选取集合才能开始转移
但是
假设我们在一个有序的序列上转移呢？（毕竟顺序不影响答案） 
回到我们的直觉，我们可以发现，我们的直觉保证了每次加的边保证是当前最大也就是说，只要这个枚举到的总和t-ai>ai，在前面的子序列桶里头出现过，就是合法
回到原本的问题。t-ai>ai的充要条件是t>2ai也就是说，我们要统计有序序列中一个[1,r]的子区间中子序列和大于ar的子序列个数
此时因该是能带一大堆log解决了，毕竟有序，我们完全可以先二分一个sj是的sj第一次大于ar，然后二分sj里面最多踢掉几个数换成j~r里的
然后枚举踢的数的个数。哦还是不能做，那很好了，毕竟能做我也不想写代码。
其实，难受的点就在于，子序列的个数是2^n的，但是我们要的很少
所以要抛开这个统计陷阱
我们让前i个数，选的数的和恰好为t的方案数在有序的序列上转移
在有序序列中，如果一直不成立，这个长度是可控的，增长速度大于斐波那契
容易证明，有序序列中，第一次满足条件，一定是形如si-1>ai
选的前缀就是1~i啊，醍醐灌顶啊
优化有点不好想，我先写出来，把70~80分拿到再说 
Yes,everything gonna be alright. 
草，刚刚茶喝多了，有点醉茶，是真的做到呕吐了www 
写了代码，问题马上暴露出来了，我的状态设计有个漏洞，这是难点。就是重复选的数会重复计数
每次都扩展一个新的数不会重复计数，但是我根本不知道前面的j里面有哪些东西。不过也好处理，这个是包含关系的，就是比如固定t，dp i t<=dp i+1 t
dp i+1 t包含了dp i t里头所有的东西。 
最后30min了，我估计多给我点时间应该能做完，来不及了，www，错失AK 
自评难度：蓝
做出恨意，做到呕吐，下午会赢的
头有点疼，同学们都AK了吧，320大众分又要倒一了
哎，没练dp计数是这样的，或许我因该去往我擅长的纯计数去想，但是这也不是我能改变的事情了
最后一次J了，没能圆梦啊。 
我要尝试纯容斥去数数
不过可以自信的，这题绝对是计数，不是一个什么图论建模，死在绿技术上也不算太冤（尤其是dp计数，我总共只写过0题，看了3题）
好好反思一下，下午不要有这种题了。
 又想了一下，纯容斥似乎做不了，这不是一个类似集合包含的题目，我可以2^n*n去数，没有重复的，排个序即可
 所以确定死了，就是dp计数，这么想能开心一点吧，但是为什么我连n^3的代码都挂了呢？
 为什么我不去写那个2^n*n的做法呢，写了就有50分啊，大家都350+，就我320
 确实很不好玩呢：（
我常常想重塑时光，却比不过岁月流转
如果我还能重回1/2年前的考场，我因该早就AK了吧
我恨计数！ 
不过想想也合理，我记得有场模拟赛的T2是这个的弱化版（是最大的三角形还是计数三角我忘了） 
反正我没做出来，我会赢的。 
*/
#include<bits/stdc++.h>
using namespace std;
long long a[6000];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	freopen("polygon.in","r",stdin);
	freopen("polygon.out","w",stdout); 
	int n;
	cin>>n;
	long long maxx=0;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		maxx=max(a[i],maxx);
	}
	if(maxx==1)
	{
		cout<<(pow(2,n)-n*(n-1)/2-1)%998244353;
		return 0;	
	}
	sort(a+1,a+n+1);
	vector<long long>s(n+1);
	for(int i=1;i<=n;i++)
	{
		s[i]=s[i-1]+a[i];
	}
	for(int o=1;o<=n;o++)
	{
		if(a[o]<s[o-1])
		{
			const int N=s[n];
			long long dp[n+1][N+1];
			for(int i=1;i<=n;i++)
			{
				for(int j=1;j<=N;j++)
				{
					dp[i][j]=0;
				}
			}
			long long ret=0;
			for(int i=0;i<=o;i++)
			{
				if(s[o-1]-s[i]>a[o])
				{
					dp[o][s[o-1]-s[i]]=1;
					ret++;
				}
			}
			for(int i=o+1;i<=n;i++)
			{
				for(int t=2*a[i];t<=N;t++)
				{
					long long cnt=0;
					for(int k=o;k<i;k++)
					{
						if(dp[k][t-a[i]]!=0)
						{
							//cout<<dp[i][t]<<"\n";
							dp[i][t]+=dp[k][t-a[i]];
							//cout<<cnt<<"\n";
							dp[i][t]-=cnt;
							cnt=dp[k][t-a[i]];
							dp[i][t]%=998244353;
							
						}
					}
					ret+=dp[i][t];
					//cout<<ret<<"\n";
					ret%=998244353;
				}
			}
			cout<<ret;
			return 0;
		}
	}
	cout<<0;
} 
