/*
如果允许选超过一半是简单的，先这样选，如果此时符合条件那么结束
否则结果必定至多只有一组超过一半，将超出的那部分分配给另外两组，注意到结果必然合法
不妨统计代价，然后做完了
O(tnlogn)

考虑如果k=0，那么等价于求原图的最小生成树，
考虑特殊性质A，本质上每个城市到其它城市的距离需要与该乡镇取较小值，然后求最小生成树
这样我们可以获得48分然后离场。
如果用克鲁斯卡尔，考虑将所有边从小到大排序，如果增加一条边可以合并两个联通块，那么合并
考虑到一个乡镇如果不和城市连边，那么根本没必要建
所以dfs枚举每个乡镇是否要建造，如果建造了，那么对整体克鲁斯卡尔
O(2^kmlogn)

考虑暴力匹配，需要枚举每个字符串的区间左端点，然后枚举二元组的个数，再枚举是否相同，复杂度是O(qnL^3)
考虑特殊性质B，可以记录每个二元组会把b移动多少位，向右为正，再记录每个询问需要移动多少位
然而每个二元组对b右侧a的个数是有要求的，这个也需要记录
问题简化为有多少个二元组满足移动次数与该问相等，且问题中的b右侧a的个数大于等于所需
所以不妨把每个二元组按b右侧a的个数排序，记录每个移动次数
对特殊性质B：O(qn)
全局：O(qnL^3)


暴力做。
O(n!)

100+64+[10,15]+8=[182,187]
1164B|1328B|1758B|574B
*/
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m,p[505],s[505],c[505],cnt,ans;
char ch;
int main(){
	freopen("employ.in","r",stdin);
	freopen("employ.out","w",stdout);
	scanf("%lld%lld",&n,&m);
	for(ll i = 1;i <= n;i++){
		scanf(" %c",&ch);
		s[i] = ch - '0',p[i] = i;
	}
	for(ll i = 1;i <= n;i++)scanf("%lld",&c[i]);
	do{
		cnt = 0;
		for(ll i = 1;i <= n;i++)if(s[i] == 1 && i - cnt - 1 < c[p[i]])cnt++;
		if(cnt >= m)ans = (ans + 1) % 998244353;
	}while(next_permutation(p + 1,p + n + 1));
	printf("%lld",ans);
	return 0;
}
