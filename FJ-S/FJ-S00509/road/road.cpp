#include<bits/stdc++.h>
using namespace std;
#define maxn 0
int a[1000100];
int b[15][1050];
int main(){
	freopen("road.in","r",stdin);
	freopen("road.out","w",stdout);
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		cin>>a[i];
	}
	for(int i=1;i<=k;i++){
		for(int j=1;j<=n;j++)
		cin>>b[i][j];
	}
	cout<<maxn;
	return 0;
} 
/*
C 国的交通系统由n 座城市与m 条连接两座城市的双向道路构成，第i (1 ≤ i ≤ m)
条道路连接城市ui 和vi。任. 意. 两. 座. 城. 市. 都. 能. 通. 过. 若. 干. 条. 道. 路. 相. 互. 到. 达. 。
然而，近期由于一场大地震，所有m 条道路都被破坏了，修复第i (1 ≤ i ≤ m) 条道路
的费用为wi。与此同时，C 国还有k 个准备进行城市化改造的乡镇。对于第j (1 ≤ j ≤ k)
个乡镇，C 国对其进行城市化改造的费用为cj。在城市化改造完第j (1 ≤ j ≤ k) 个乡镇
后，可以在这个乡镇与原来的n 座城市间建造若干条道路，其中在它与第i (1 ≤ i ≤ n)
座城市间建造一条道路的费用为aj,i。C 国可以在这k 个乡镇中选择任. 意. 多. 个. 进行城市
化改造，也可以不选择任何乡镇进行城市化改造。
为尽快恢复城市间的交通，C 国政府希望以最低的费用将原. 有. 的n 座城市两两连
通，也即任意两座原有的城市都能通过若干条修复或新建造的道路相互到达。你需要帮
助他们求出，将原有的n 座城市两两连通的最小费用。



特殊性质A：对于所有1 ≤ j ≤ k，均有cj = 0 且均存在1 ≤ i ≤ n 满足aj,i = 0。
*/
