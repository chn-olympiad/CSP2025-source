#include<bits/stdc++.h>
#define int long long
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
using namespace std;
struct Node {
    int w, a, b;
    friend bool operator < (const Node&a,const Node&b) {
        return a.w < b.w;
    }
}v[1000000 + 100000 + 5], bck[1000000 + 5];
int n, m, k, cost[10], c[10][10000 + 5];
int fa[10000 + 10 + 5], siz[10000 + 10 + 5];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
bool merge(int u, int v) {
    int x = find(u), y = find(v);
    if (x == y) return 0;
    if (siz[x] > siz[y]) swap(x, y);
    fa[x] = y;
    siz[y] += siz[x];
    return 1;
}
struct Node2 {
    int cost, c[10000 + 5], srt;
    void make_from(int idx) {
        cost = ::cost[idx];
        srt = 0;
        for (int i = 1; i <= n; ++i) {
            srt += c[i] = ::c[idx][i];
        }
        srt /= n;
        srt += cost;
    }
    void make_to(int idx) {
        ::cost[idx] = cost;
        for (int i = 1; i <= n; ++i) {
            ::c[idx][i] = c[i];
        }
    }
    friend bool operator<(const Node2&a, const Node2&b) {
        return a.srt < b.srt;
    }
}d[10];
int32_t main() {
    file(road);
    cin.tie(0)->sync_with_stdio(false);
    cin >> n >> m >> k;
    for (int i = 1, u, v, w; i <= m; ++i) {
        cin >> u >> v >> w;
        bck[i] = { w,u,v };
    }
    for (int i = 0; i < k; ++i) {
        cin >> cost[i];
        for (int j = 1; j <= n; ++j)
            cin >> c[i][j];
    }
    for (int i = 0; i < k; ++i) d[i].make_from(i);
    sort(d, d + k);
    for (int i = 0; i < k; ++i) d[i].make_to(i);
    int anss = LLONG_MAX;
    for (int i = 0, lim = 1 << k; i < lim; ++i) {
        memcpy(v, bck, sizeof bck);
        int idx = m, cnt = n - 1, ans = 0;
        for (int j = 0; j < k; ++j)
            if (i & (1 << j)) {
                cnt++; ans += cost[j];
                for (int k = 1; k <= n; ++k)
                    v[++idx] = { c[j][k],n + j + 1,k };
            }
        sort(v + 1, v + idx + 1);
        iota(fa + 1, fa + n + k + 1, 1);
        fill(siz + 1, siz + n + k + 1, 1);
        // for (int j = 1; j <= n + __builtin_popcount(i); ++j) assert(fa[j] == j);
        int tot = 0;
        for (int i = 1; i <= idx; ++i) {
            if (merge(v[i].a, v[i].b)) {
                ans += v[i].w;
                if (++tot == cnt) break;
            }
        }
        if (tot == cnt) anss = min(anss, ans);
        // cerr << tot << ' ' << cnt << ' ' << ans << endl;
        if (clock() > CLOCKS_PER_SEC * 0.95) break;
    }
    cout << anss << endl;
    return 0;
}
/*
有思路了，可以使用可持久化并查集维护父子关系，然后每次修改时找版本，看一下是否更优，时间复杂度是两只log的，可以过，但是码量有点大，等会写完 T3/T4 暴力再回来写 T2

一个小时，应该写的完吧。
*/