#define allLL
#include<bits/stdc++.h>
using namespace std;
#define N 500005
template<typename T>T Max(T x,T y){return (x<y?y:x);} 
template<typename T>T Min(T x,T y){return (x<y?x:y);}
#define LL long long
#ifdef allLL
#define int LL
const int INF=(1e18);
#else
const int INF=(1e9);
#endif
template<typename T>void read(T&x){
x=0;char c=getchar();/*T fh=1;*/
while(c<'0'||'9'<c){/*if(c=='-'){fh=-1;}*/c=getchar();}
while('/'<c&&c<':'){x=x*10+(c^'0');c=getchar();}/*x*=fh;*/}
template<typename T>void write(T x){
if(x<0){putchar('-');x=-x;}if(x>9){write(x/10);}putchar('0'+(x%10));}
int a[N][5];
int n;
int cnt[4];

priority_queue<int> q[4];
#undef int
int main(){
#ifdef allLL
#define int LL
#endif
	freopen("club.in","r",stdin);
	freopen("club.out","w",stdout);
	int T;
	read(T);
	while(T--){
		read(n);
		int sm=0;
		while(q[1].size())q[1].pop();
		while(q[2].size())q[2].pop();
		while(q[3].size())q[3].pop();
		cnt[1]=cnt[2]=cnt[3]=0;
		for(int i=1;i<=n;i++){
			read(a[i][1]);
			read(a[i][2]);
			read(a[i][3]);
			int f1=1,f2=0;
			if(a[i][2]>a[i][f1])f2=f1,f1=2;
			else if(a[i][2]>a[i][f2])f2=2;
			if(a[i][3]>a[i][f1])f2=f1,f1=3;
			else if(a[i][3]>a[i][f2])f2=3;
			q[f1].push(a[i][f2]-a[i][f1]);
			if(cnt[f1]>=(n>>1)){
				sm+=q[f1].top();
				q[f1].pop();
				cnt[f1]--;
			}
			sm+=a[i][f1];
			cnt[f1]++;
//			h[i]={a[i][1]-a[i][2],i};
		}
//		cerr<<"::::::";
		write(sm);
		puts("");
	}
//	cerr<<clock()<<endl;////
	return 0;
#undef int
}
/*
1
10
2020 14533 18961
2423 15344 16322
1910 6224 16178
2038 9963 19722
8375 10557 5444
3518 14615 17976
6188 13424 16615
8769 509 4394
958 3195 9953
16441 5313 10926
*/

/*
147325
*/

/*
luogu 544571

我要玩原神！！！！！！ 

预估 100+100+100+28=328，不挂就是赢

## T1-club

有 n 个人，n为偶数。

要把每个人分配到某个部门，一共三个部门。

给出 n*3 的矩阵表示每个人对这个部门的满意度。

要求最大化分配到的满意度总和，且要求每个部门最多 n/2 个人。

那就有一个很显然的想法是 $f_{i,x,y,z}$ 表示考虑前 i 个数，三个部门人数分别为 xyz 最大贡献。

然后可以干掉一维，$f_{i,x,y}$。

显然可以网络流，但是很不好，这可是 -ST1。

反悔贪心吗

想性质。

A 乱做。

B 呢？

按照 a1-a2 排序，前一半选 1，后一半选 2。

如果在此基础上加入 3 呢？

贪心地选最大的几个。

不会证，试试

---

哦错的，我自己可以轻松卡掉。

？数据范围 ai <=2e4

瓦。

有操作吗

如果我们先固定其中一个部门分配的人数呢

贪心不对！

反悔贪心。

每次选最大的一个。

然后会发现不够用。

就尝试腾位置出来。

然后会发现很强的事情。

最多只有一个部门被顶满。

那就是说剩下两个直接贪心选择就好了。

---

感觉我T1做复杂了，怎么还反悔贪心的。

## T2-road

给定一张五香联通图。

香。

初始所有边都被破坏，修复一条边 w 的代价为 wi。

还有一个操作，给了 k 个新点，建立新点 j 的代价为 cj。建立完成后，可以用 aj,i 的代价在新点 j 和原点 i 之间连边。

求最小费用。

注意到 $m\le 10^6,n\le 10^4$

再注意到 $k\le 10$。

没有 k 就是 MST。

有的话

不妨枚举一下。

哦，可以 LCT 强行动态维护，但是很蠢。

直接枚举是 $O(2^k (m+kn)\log m)$ 的复杂度。

补队，kruscal 其实在已经排好序之后是 $n\log m$ 的复杂度。

所以我们把 kn 条边排好，原图上的排好

补队，是 $m\log n$。

不妨先枚举一下造哪些点。

---

看一下性质

造点不需要代价且造出来一定能免费和某个点连接。

那直接全部造出来 MST 就好了。

额我是不是可以先把原图的 MST 跑出来

然后就做完了吧。

$O(m\log m+2^k(n+kn)\log n)$

eee，多了个log。

好烦。

额其实

那 kn 条边也能先排好序。

然后就是 $O(m\log m+2^k(n\alpha+kn))$

jiandan

可以再优化干掉一个 k，但是懒。

## T3

有 n 个字符串二元组(s1_i,s2_i)，定义字符串替换操作是可以选择一段为 $(s1_i)$ 的子串替换为 $s2_i$。

一个串只能替换一次。

多次询问，每次给定两个串 t1,t2 问有多少个替换方案可以使 t1 变成 t2。

位置不同或者使用的二元组编号不同都是算作不同的方案。

哈希。

扫。

看一下要的东西是否出现。

做完了？？？

没有。

因为你要枚举替换起点，还要枚举替换长度。

就是个 $L^2$ 的复杂度，很弱。

挖取，AC 自动机。

匹配过程中发现匹配上了就尝试替换。

但是还是会炸，如果一个起点有多个能替换的一样爆掉。

首先我们可以找出 t1,t2 相同的最长前后缀。

设中间不同的一段是 t3

那能替换的只有包含了 t3 的东西。

同时我们还能再求出每对 s1s2，同样求出这个东西。设为 s3

那就要求 s3=t3。

这个性质很强。

此时这些东西已经能保证能把 t1 替换为 t2 了，唯一的问题就是说能否填进去。

yuanshen

qidong

我要抽水神！！！！！！！！！！！！！！！！！

---

我不会做。

暂时。

---

推性质。

首先我们直接做是个 $O(nq)$ 的东西。可以获得 40 分。

就是找到我们要搞的位置。然后判定。

其实是 50 分，因为还有性质 A。

考虑性质 B。

那就是 s3 t3 均为"b"。

有啥用呢

数一下长度即可。

我觉得我挺接近正解的。

除了 s3t3 剩下的东西。

注意到一对 s1 s2 可以视为三个部分，前面的，后面的，s3。

不过实际上 s3 是两个字符串，不管不重要。

如果建立 AC 自动机呢

匹配到一个串

还会带上其后缀。

不管了，根分。

s2 足够长的情况下直接暴力。

s2 短。

注意这样的数量是可以很多的。

怎么做呢

现在能不能枚举长度了？

或者 bitset？

单次 $b^2$ 可以做到。

那整体的复杂度怎么算？

注意到 $a^2+b^2<=(a+b)^2$。

所以一定是很多很多全部放一起最慢。

那就是 $\min(\frac{L}{B},q)\times B^2$

显然爆了。

那能不能 bitset 优化。

可以做到单次 $$

这么强

---

考虑离线。

s3t3 相同的一起处理。

？

我是什么东西

这都没想到

根本就不需要这一对操作。

建立 AC 自动机，但是干掉 s3 t3的部分。

然后直接匹配就完了。

每个 s3 t3 都开一个。

虽然这两天没复习到，但是复习了这么多次总是能打出来的吧。

---

打一半发现假的。

因为你无法保证是恰好包含了中间一坨。

能不能容掉啊。

现在是包含+不包含。

直接不包含貌似也能算。

---

不对就是真的。

因为强制包含完啊，定义一个特殊字符就好了。

---

春风得意羊蹄疾，一日看尽夏威夷。

爽。

现在写的是ACAM上暴力查询，考虑一下怎么优化。

这里应该是个普及组问题。

首先就是个树上打标记

线段树能搞不

链覆盖单点查。

可以吧。

但是好丑，双log。

过不去啊

---

发现不用标记，因为查询的特性使得每个点刚好被搞一次





## T4

所有的结果是一样的。

那就是要把人填进去。

不要望而却步。

但是这类题一直不擅长。

先找性质。

如果一个人被安排在了一定爆炸的位置，那不用管他。

首先如果按照 c 从小到大排序。

求出哪些人会炸。

然后考虑交换两个人。

如果

G

我们来考虑填人。

只考虑填进 1。

如果自己炸了就相当于在自己这个位置再插一个 0。

从小到大填。

也不好做。

考虑死人。

填在 0 上就不管了。

填在 1 上呢

首先它得死。

那就要求前面死人够多。然后他还会对后面产生影响。

---

不会，推部分分

$n\le 10$ 爆搜。

$n\le 20$ 枚举每个位置死不死。

然后就填。

填的时候每个点能填的数是个前缀，且这个前缀越来越长。

那直接乱算一下就好了。

性质 B 也是一样的。

m=1 呢

那就是看不能录取任何人的方案数。

一样一样的。

m=n 呢？

所有人都要被录取。


性质 A 呢？乱填。

---

G我有想法了。

容一下斥

枚举一下当前至少死多少人。

那就选若干个位置弊掉。

---

G不对啊

n<=18 有点不对。

应该从人的角度考虑。

如果填进原本 0 的位置就不用管了。

如果填进现在是 0 的位置呢

神志不清了，上个厕所先。

这样的位置就要求是某个后缀。

1 就是相反的那个前缀。

这咋玩

从小到大排序，那么 1 就是个不断递增的前缀。

$f_{i,j,k}$ 表示考虑前 i 个点，填了 j 个 0，k 个 1。

那么 1 的范围就要减少k。0 的范围呢？

不好搞，不管了。

不过还是能玩 m=1。

---

啥也别管了，乱玩了。

*/
