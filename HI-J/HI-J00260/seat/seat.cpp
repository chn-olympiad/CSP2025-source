#include<bits/stdc++.h>
using namespace std;
int N = 1e5 + 5;
int main()
{
	freopen("seat.in", "r", stdin);
	freopen("seat.out", "w", stdout);
	int n, m, a[N][N], c, r, num[N][N];
	cin >> n >> m;    //n代表行,m代表列 
	for(int i = 0; i < n - 1; i++)
	{
		for(int j = 0; j < m; j++)
		{
		cin >> a[i][j];
		}
		
		for(int j = m; j > 0; j--)
		{
		cin >> a[i + 1][j];
		}
	}
	num[0][0] = a[0][0];
	for(int i = 1; i <= N; i++)
	{
		for(int i = 0; i < n; i++)
		{
			for(int j = 0; j < m; j++)
			{
				if(j = m - 1)
				{
					swap(a[i][j], a[i + 1][0]);
				}
				else
				{
					if(a[i] < a[i + 1])
					{
						swap(a[i][j], a[i][j + 1]);
					}
				}
			}
		}
	}
	
	for(int i = 0; i < n; i++)
	{
		for(int j = 0; j < m; j++)
		{
			if(num[0][0] == a[i][j])
			{
				c = i / m; //列 
				r = i / n; //行 
				cout << c << " " << r;
			}
		}
		
	}
	
	/*
	总人数：1 ×3(n ×m).
	比较a[0]、a[1]、a[2],
	从大到小排列： 
		假设 a[2] > a[0] > a[1];
		先比较a[0]和 a[1].
		通过.
		然后比较a[0]和 a[2];
		由于a[2] > a[0], swap(a[0], a[2]);
		通过.
		目前的一串数组为 ：a[2], a[1], a[0].
		再比较a[1]和 a[0];
		swap(a[1], a[0]);
		通过.
		最终的一串数组为：a[2], a[0], a[1].
		符合要求. 
	*/
	
	
	
	/*
	
	把人数调大一些： 
	
	总人数：3 ×3(n ×m).
	比较a[0]、a[1]、a[2]、a[3]、a[4]、a[5]、a[6]、a[7]、a[8],
	从大到小排列： 
		假设这串数组分别为：2 4 7 1 3 8 10 21 6;
	・・・・・・・・・・・・・・・・・・・・・・・・・・・・・ 
	*/
	
	
	
	/*
	现在要考虑如何在排列时计数. 
	在这之前,先明确一下计数的目的和目标,即达到的效果.
	计数的目的：
		当两个数比较完了之后，可能有一个数到达了它该去的位置,比如最高位或最低位. 这时就要给它下一个最后通牒,防止它的
		位置变更. 
		当然,如果真在最高位或最低位的话,也就没必要去计数了,因为不会有别的数比它还小/还大了.
		还有一个,如果排列完一遍还没有符合题意(即 还需要在排列一次),那么就需要用过计数再排列一次.
	*/ 
	
	
	
	/*
	Now,想一想该咋写.
	是不是要用for语句？可用for语句干啥呢？for语句是限定循环执行次数, emmm....或许也能用.
	再想一想循环体.
	现在是要循环排列,所以循环体应该是要用于排列的代码,比如swap.
	再来想一想循环次数i的条件.
	首先 i = 1, 其次考虑 i <= ? 
	?代表i的最大值.
	是否可以用嵌套循环？
	如果用嵌套循环的话,就会有i和 j两个变量,
	或许...可以分别代表行和列？
	也许这是个好方法.
	  
	来模拟一下,使n和 m分别代表行和列. 
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m)
		{
		
		}
	}
	*/
	
	return 0;
}
